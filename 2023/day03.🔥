# https://adventofcode.com/2023/day/3
#
# --- Day 3: Gear Ratios ---
#
# You and the Elf eventually reach a gondola lift station; he says the gondola
# lift will take you up to the water source, but this is as far as he can bring
# you. You go inside.
#
# It doesn't take long to find the gondolas, but there seems to be a problem:
# they're not moving.
#
# "Aaah!"
#
# You turn around to see a slightly-greasy Elf with a wrench and a look of
# surprise. "Sorry, I wasn't expecting anyone! The gondola lift isn't working
# right now; it'll still be a while before I can fix it." You offer to help.
#
# The engineer explains that an engine part seems to be missing from the engine,
# but nobody can figure out which one. If you can add up all the part numbers in
# the engine schematic, it should be easy to work out which part is missing.
#
# The engine schematic (your puzzle input) consists of a visual representation
# of the engine. There are lots of numbers and symbols you don't really
# understand, but apparently any number adjacent to a symbol, even diagonally,
# is a "part number" and should be included in your sum. (Periods (.) do not
# count as a symbol.)
#
# Here is an example engine schematic:
#
# ```
# 467..114..
# ...*......
# ..35..633.
# ......#...
# 617*......
# .....+.58.
# ..592.....
# ......755.
# ...$.*....
# .664.598..
# ```
#
# In this schematic, two numbers are not part numbers because they are not
# adjacent to a symbol: 114 (top right) and 58 (middle right). Every other
# number is adjacent to a symbol and so is a part number; their sum is 4361.
#
# Of course, the actual engine schematic is much larger. What is the sum of all
# of the part numbers in the engine schematic?

# Ideas:
#
# 1. look around number
# ```
# for each character
#   if digit
#     start number parsing to collect into one while looking for nearby symbols
#     if there was a symbol
#       add to count
# ```
#
# 2. look around symbol
# ```
# for each character
#   if symbol
#     look for neighboring digits and parse outwards, storing first digit's
#     position in a set so we know duplicates
# ```
#
# 3. multiple passes
# ```
# perform multiple passes
# first pass: collapse digits into a number and track if next to symbol
# second pass: sum those numbers which were next to symbol
# ```
#
# 4. one pass with a state machine
# ```
# compare against previous line as you go
# collapse digits into a number
#
# on '.'->digit, check top left and top for symbol
# on digit or digit->'.', check top for symbol
# if symbol found or on digit->symbol, add to count and first index to set
#
# on symbol, check top left, top, top right for digit
#   if digit found, add to count and first index to set
# ```
#
# In all of the above, could pad the grid with '.' to facilitate lookups


fn main():
    print("Hello, day 3")
