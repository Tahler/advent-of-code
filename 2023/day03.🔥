# https://adventofcode.com/2023/day/3
#
# --- Day 3: Gear Ratios ---
#
# You and the Elf eventually reach a gondola lift station; he says the gondola
# lift will take you up to the water source, but this is as far as he can bring
# you. You go inside.
#
# It doesn't take long to find the gondolas, but there seems to be a problem:
# they're not moving.
#
# "Aaah!"
#
# You turn around to see a slightly-greasy Elf with a wrench and a look of
# surprise. "Sorry, I wasn't expecting anyone! The gondola lift isn't working
# right now; it'll still be a while before I can fix it." You offer to help.
#
# The engineer explains that an engine part seems to be missing from the engine,
# but nobody can figure out which one. If you can add up all the part numbers in
# the engine schematic, it should be easy to work out which part is missing.
#
# The engine schematic (your puzzle input) consists of a visual representation
# of the engine. There are lots of numbers and symbols you don't really
# understand, but apparently any number adjacent to a symbol, even diagonally,
# is a "part number" and should be included in your sum. (Periods (.) do not
# count as a symbol.)
#
# Here is an example engine schematic:
#
# ```
# 467..114..
# ...*......
# ..35..633.
# ......#...
# 617*......
# .....+.58.
# ..592.....
# ......755.
# ...$.*....
# .664.598..
# ```
#
# In this schematic, two numbers are not part numbers because they are not
# adjacent to a symbol: 114 (top right) and 58 (middle right). Every other
# number is adjacent to a symbol and so is a part number; their sum is 4361.
#
# Of course, the actual engine schematic is much larger. What is the sum of all
# of the part numbers in the engine schematic?

# Ideas:
#
# 1. look around number
# ```
# for each character
#   if digit
#     start number parsing to collect into one while looking for nearby symbols
#     if there was a symbol
#       add to count
# ```
#
# 2. look around symbol
# ```
# for each character
#   if symbol
#     look for neighboring digits and parse outwards, storing first digit's
#     position in a set so we know duplicates
# ```
#
# 3. multiple passes
# ```
# perform multiple passes
# first pass: collapse digits into a number and track if next to symbol
# second pass: sum those numbers which were next to symbol
# ```
#
# 4. one pass with a state machine
# ```
# compare against previous line as you go
# collapse digits into a number
#
# on '.'->digit, check top left and top for symbol
# on digit or digit->'.', check top for symbol
# if symbol found or on digit->symbol, add to count and first index to set
#
# on symbol, check top left, top, top right for digit
#   if digit found, add to count and first index to set
# ```
#
# In all of the above, could pad the grid with '.' to facilitate lookups
#
# I'll go with #1 -- seems easiest to implement.


fn main() raises:
    let grid = read_grid("2023/day03.txt")
    let padded = PaddedGrid(grid, ".")
    let indexes = padded.indexes()

    var sum_part_numbers = 0
    # I wish Mojo ðŸ”¥ understood that `var` now and `+=` later means that this is
    # a `String`, not a `StringLiteral`.
    var raw_number: String = ""
    var raw_number_is_adjacent_to_symbol = False
    for i in range(len(indexes)):
        let index = indexes[i]
        let cell = padded[index]
        if is_digit(cell):
            raw_number += cell
            # This redundantly checks the same cells multiple times, which could
            # be improved a bit by only checking the left if we haven't seen a
            # number yet.
            if not raw_number_is_adjacent_to_symbol and padded.has_adjacent_symbol(
                index
            ):
                raw_number_is_adjacent_to_symbol = True
            continue
        let passed_number = raw_number != ""
        if passed_number:
            if raw_number_is_adjacent_to_symbol:
                let part_number = atol(raw_number)
                sum_part_numbers += part_number
            raw_number = ""
            raw_number_is_adjacent_to_symbol = False
    print(sum_part_numbers)


alias Point = Tuple[Int, Int]


struct PaddedGrid:
    var grid: Grid
    var pad: String

    fn __init__(inout self, grid: Grid, pad: String):
        self.grid = grid
        self.pad = pad

    fn __getitem__(self, index: Point) -> String:
        let row_i = index.get[0, Int]()
        let col_i = index.get[1, Int]()
        let rows = self.grid
        if row_i < 0 or row_i >= len(rows):
            return self.pad
        let row = rows[row_i]
        if col_i < 0 or col_i >= len(row):
            return self.pad
        return row[col_i]

    fn indexes(self) -> DynamicVector[Point]:
        var points = DynamicVector[Point]()
        let rows = self.grid
        for row_i in range(len(rows)):
            let row = rows[row_i]
            for col_i in range(len(row)):
                points.append((row_i, col_i))
        return points

    fn has_adjacent_symbol(self, index: Point) -> Bool:
        let row_i = index.get[0, Int]()
        let col_i = index.get[1, Int]()

        let top_left = self[(row_i - 1, col_i - 1)]
        let top = self[(row_i - 1, col_i)]
        let top_right = self[(row_i - 1, col_i + 1)]
        let left = self[(row_i, col_i - 1)]
        let right = self[(row_i, col_i + 1)]
        let bottom_left = self[(row_i + 1, col_i - 1)]
        let bottom = self[(row_i + 1, col_i)]
        let bottom_right = self[(row_i + 1, col_i + 1)]
        # I wish Mojo ðŸ”¥ had more native __iter__ implementations.
        return (
            is_symbol(top_left)
            or is_symbol(top)
            or is_symbol(top_right)
            or is_symbol(left)
            or is_symbol(right)
            or is_symbol(bottom_left)
            or is_symbol(bottom)
            or is_symbol(bottom_right)
        )


alias Row = DynamicVector[String]
alias Grid = DynamicVector[Row]


fn read_grid(path: String) raises -> Grid:
    """Parses the 2D grid from the given file, replacing symbols with '*'."""
    with open(path, "r") as f:
        let content = f.read()
        let lines = content.split("\n")

        var grid = Grid()
        if len(lines) == 0:
            return Grid()

        for i in range(len(lines)):
            let line = lines[i]

            var row = Row()
            for j in range(len(line)):
                let c = line[j]
                row.append(c)
            grid.append(row)

        return grid


fn is_symbol(s: String) -> Bool:
    return not (is_digit(s) or s == ".")


fn is_digit(s: String) -> Bool:
    try:
        _ = atol(s)
        return True
    except:
        return False
